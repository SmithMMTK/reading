
หลังจากเลือก _model framework_ และแปลงข้อมูลเรียบร้อยแล้ว คุณจำเป็นต้องสร้าง _relationships_ เพื่อให้สามารถกรองและสรุปข้อมูลโดยอิงจากข้อมูลใน _table_ อื่นได้ โดยทั่วไปจะใช้การออกแบบแบบ _star schema_ และตั้งกฎให้ _dimension tables_ เป็นตัวกรอง เพื่อให้ _model relationships_ สามารถนำ _filter_ ไปใช้กับ _fact tables_ ได้อย่างมีประสิทธิภาพ

## Create a star schema

ในกรณีของเรา เรานำเข้าตาราง _dimension_ จากไฟล์ .csv ซึ่งต้องเชื่อมต่อกับ _lakehouse_ คุณสามารถสร้าง _relationships_ เพื่อจัดรูปแบบเป็น _star schema_ หลังจากที่ตารางที่นำเข้าถูกแปลงแล้ว

ใน _star schema_ ตาราง _fact_ และ _dimension_ จะทำงานร่วมกันเพื่อจัดระเบียบและวิเคราะห์ข้อมูล โดยตาราง _fact_ จะเก็บข้อมูลหลักเกี่ยวกับกิจกรรมทางธุรกิจ เช่น ยอดขายหรือเหตุการณ์ต่าง ๆ ในขณะที่ _dimension tables_ จะให้บริบทและข้อมูลเชิงพรรณนาเพิ่มเติม

ตัวอย่างเช่น หากคุณมี _sales fact table_ ตารางนี้อาจเก็บข้อมูลยอดขายและวันที่ของแต่ละรายการขาย ในขณะที่ _dimension tables_ จะให้ข้อมูลเพิ่มเติม เช่น ข้อมูลลูกค้า รายละเอียดสินค้า และช่วงเวลา เมื่อเชื่อมโยง _fact table_ กับ _dimension tables_ แล้ว คุณจะสามารถกรอง จัดกลุ่ม และวิเคราะห์ข้อมูลได้อย่างง่ายดาย

![Diagram showing a fact table in the center and multiple dimension tables connected by relationships organized in a star-like shape with a star background to explain the reason behind the star schema name.](https://learn.microsoft.com/en-us/training/wwl/design-scalable-semantic-models/media/model-frameworks-star-schema-design.png)

## Create relationships

การสร้าง _relationships_ ระหว่าง _fact_ และ _dimension tables_ สามารถทำได้โดยการระบุคอลัมน์ที่เกี่ยวข้องในแต่ละตารางแล้วสร้างความสัมพันธ์ขึ้นมา ในแหล่งข้อมูลแบบเชิงสัมพันธ์ เช่น ฐานข้อมูลหรือ _data warehouse_ คอลัมน์เหล่านี้มักเรียกว่า _keys_ หากไม่มีคอลัมน์ _key_ ให้พิจารณาโครงสร้างของตารางเพื่อดูว่าจะใช้คอลัมน์ใดในการสร้าง _relationship_

ประเภทของ _relationships_ มีหลายแบบ:

- **One-to-Many** เป็นประเภทที่พบบ่อยที่สุด โดยหนึ่งแถวในตารางหนึ่งสามารถเชื่อมโยงกับหลายแถวในอีกตารางหนึ่ง โดยปกติแล้วจะเชื่อมจาก _dimension table_ ที่มีค่าไม่ซ้ำกัน ไปยัง _fact table_ ที่มีหลายแถวที่สัมพันธ์กับค่าดังกล่าว
- **Many-to-One** มีลักษณะเหมือนกับ _One-to-Many_ แต่ขึ้นอยู่กับทิศทางของการกรองที่ตั้งค่าไว้ระหว่างตาราง
- **One-to-One** พบได้น้อยกว่า โดยทั้งสองตารางมีข้อมูลที่ไม่ซ้ำกัน พิจารณาว่าควรรวมตารางทั้งสองเข้าด้วยกันหรือไม่
- **Many-to-Many** ก็พบได้น้อยแต่จำเป็นสำหรับข้อมูลที่ซับซ้อน โดยให้หลายแถวในตารางหนึ่งเชื่อมโยงกับหลายแถวในอีกตารางหนึ่งได้

ในกรณีที่เป็น _Many-to-Many_ อาจจำเป็นต้องใช้ **bridge table** เพื่อจัดการความสัมพันธ์โดยใช้ _intermediary keys_ นอกจากนี้ _composite models_ ยังช่วยรองรับ _Many-to-Many relationships_ โดยการรวมข้อมูลจากแหล่งที่มาต่างกันได้

### Filter direction

เมื่อคุณสร้าง _relationship_ คุณสามารถกำหนดทิศทางของการกรองข้อมูลจากตารางหนึ่งไปยังอีกตารางหนึ่งได้ โดยปกติใน _star schema_ ทิศทางการกรองจะไหลจาก _dimension table_ ไปยัง _fact table_ เพื่อให้ _dimension table_ กรองผลลัพธ์ของ _fact table_

**Bi-directional filters** ก็สามารถใช้ได้เช่นกัน โดยมักใช้ในกรณี _One-to-One_ หรือ _Many-to-Many_ ก่อนใช้งานควรตรวจสอบให้แน่ใจว่า _data_ และ _relationships_ ถูกตั้งค่าไว้อย่างถูกต้อง เนื่องจาก _bi-directional filters_ อาจส่งผลต่อประสิทธิภาพของการสืบค้นใน _model_ และอาจสร้างความสับสนให้กับผู้ใช้รายงาน

**Referential integrity** เป็นการรักษาความสัมพันธ์ของข้อมูลระหว่างตารางให้ถูกต้อง หมายถึงทุกค่าในคอลัมน์ _foreign key_ ต้องมีค่าที่ตรงกับคอลัมน์ _primary key_ ของตารางที่เชื่อมโยงกัน ฟีเจอร์นี้ยังช่วยเพิ่มประสิทธิภาพในการสืบค้นเมื่อใช้ _INNER join_ แทนที่จะใช้ _LEFT OUTER join_

ความเข้าใจเรื่องทิศทางของ _filter_ และ _referential integrity_ มีความสำคัญต่อความถูกต้องของการสร้างแบบจำลองข้อมูล เพราะ _filters_ จะสามารถใช้งานได้ต่อเมื่อ _relationship path_ ถูกต้องและเป็นไปตามทิศทางที่กำหนดไว้

### Inactive relationships

---
	~~บางครั้ง _relationships_ จะถูกปิดใช้งาน และมีการเปลี่ยนแปลง _filter context_ โดยใช้ฟังก์ชัน _DAX_ ซึ่งอาจจำเป็นเมื่อมีมากกว่าหนึ่ง _relationship_ ระหว่างตาราง แต่สามารถเปิดใช้งานได้เพียงหนึ่งความสัมพันธ์ในช่วงเวลานั้น ในกรณีนี้ ให้ใช้ฟังก์ชัน `USERELATIONSHIP` ใน _DAX_ เพื่ออ้างอิง _inactive relationship_ เพื่อให้ได้ผลลัพธ์ของการกรองเหมือนกับความสัมพันธ์ที่เปิดใช้งาน ตัวอย่าง:~~

--- 

**บางครั้งตารางเดียวกันอาจมีหลายเส้นทางความสัมพันธ์ (relationship)** แต่ **Power BI เลือกเปิดใช้งาน (active) ได้ครั้งละเส้นเท่านั้น** เพื่อไม่ให้สับสนว่าเวลาเรากรองข้อมูล จะใช้เส้นทางไหน **ถ้าเราอยากใช้เส้นที่ถูกปิด (inactive)** เราต้องสั่ง Power BI ด้วยฟังก์ชัน USERELATIONSHIP ใน DAX เพื่อบอกว่า

> “เฮ้ ใช้เส้นนี้ในการกรองข้อมูลนะ”

**ตัวอย่าง:**
- ปกติรายงานอาจดึงยอดขายตาม OrderDate (active)
- แต่ถ้าอยากดูยอดขายตาม ShipDate (inactive)
    เราต้องใช้ USERELATIONSHIP เพื่อบังคับให้มันใช้เส้น ShipDate
---
**สรุปสั้น ๆ:**
USERELATIONSHIP = ปุ่มเปิดใช้เส้นทางความสัมพันธ์ที่ถูกปิดอยู่ ชั่วคราว ในสูตรนั้น ๆ เท่านั้น

```DAX
CALCULATE(
    SUM(Sales[Amount]),
    USERELATIONSHIP(Sales[Date], Calendar[Date])
)
```

การใช้ฟังก์ชัน _DAX_ กับ _relationships_ มีประโยชน์เพราะช่วยให้คุณสามารถสร้างการคำนวณที่ยืดหยุ่นและปรับเปลี่ยนได้ตามสถานการณ์ของข้อมูล ซึ่งเหมาะสำหรับ _data model_ ที่ซับซ้อนและการวิเคราะห์ขั้นสูง

|**ความสัมพันธ์**|**ใช้งานปกติในรายงาน?**|**ใช้ในสูตร** USERELATIONSHIP **ได้ไหม?**|
|---|---|---|
|OrderDate (Active)|✅ ใช้ได้ทุก visual และ measure|✅ ได้ (แต่ไม่จำเป็นเพราะมัน active อยู่แล้ว)|
|ShipDate (Inactive)|❌ ไม่ถูกใช้โดยอัตโนมัติ|✅ ได้ โดยใช้ USERELATIONSHIP()|
## **Use disconnected tables**

โดยปกติแล้ว _model table_ มักจะมีความสัมพันธ์กับตารางอื่น แต่หากไม่มี ตารางนั้นจะเรียกว่า _disconnected table_ ซึ่งไม่ได้มีไว้เพื่อให้ _filter_ แพร่กระจายไปยัง _model tables_ อื่น แต่จะใช้สำหรับรับ “ค่าจากผู้ใช้” เช่นผ่าน _slicer visual_ เพื่อให้การคำนวณใน _model_ ใช้ค่าที่ผู้ใช้เลือกได้อย่างมีประโยชน์ ตัวอย่างเช่น ตาราง _disconnected_ ที่มีช่วงของอัตราแลกเปลี่ยนเงินตรา เมื่อกรองค่าหนึ่งค่าจากตารางนี้ การเขียน _measure_ สามารถนำค่านั้นมาใช้แปลงยอดขายได้

ฟีเจอร์ _what-if parameter_ ใน _Power BI Desktop_ จะสร้าง _disconnected table_ ขึ้นมา สำหรับข้อมูลเพิ่มเติม โปรดดูที่ [Create and use a What if parameter to visualize variables in Power BI Desktop](https://learn.microsoft.com/en-us/power-bi/transform-model/desktop-what-if)

