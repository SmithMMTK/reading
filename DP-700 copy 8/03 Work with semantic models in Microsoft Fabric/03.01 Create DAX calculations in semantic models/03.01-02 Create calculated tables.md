
_calculated table_ คือ ตารางที่สร้างขึ้นจากสูตร _DAX_ ซึ่งคืนค่ากลับเป็น _table object_ ช่วยให้คุณสามารถคัดลอกหรือแปลงข้อมูลที่มีอยู่ในโมเดลเพื่อสร้างตารางใหม่ได้

## Duplicate a table

ปัญหาหนึ่งที่พบบ่อยในการออกแบบ _data model_ คือการจัดการกับความสัมพันธ์แบบหลายชุดระหว่างตาราง เช่น ตาราง _Sales_ อาจมีความสัมพันธ์ 3 รายการกับตาราง _Date_ ได้แก่ _Order Date_, _Ship Date_, และ _Due Date_

[![Screenshot shows two tables: Sales and Date. There are three relationships between the tables. Only one relationship is active.](https://learn.microsoft.com/en-us/training/modules/dax-power-bi-create-calculations/media/dax-sales-date-relationships.png)](https://learn.microsoft.com/en-us/training/modules/dax-power-bi-create-calculations/media/dax-sales-date-relationships.png#lightbox#lightbox)

ในแผนภาพ ตัวอย่างแสดงให้เห็นว่ามีความสัมพันธ์ 3 ชุด แต่สามารถเปิดใช้งานได้ทีละรายการเท่านั้น ความสัมพันธ์ที่เปิดใช้งานจะใช้เส้นทึบ ส่วนที่ไม่เปิดใช้งานจะใช้เส้นประ

ในตัวอย่างนี้ ความสัมพันธ์ที่เปิดใช้งานจะเชื่อมต่อกับคอลัมน์ _OrderDateKey_ ในตาราง _Sales_ ทำให้การกรองข้อมูลจาก _Date_ มีผลกับยอดขายตาม _Order Date_ เท่านั้น

หากต้องการกรองยอดขายตาม _Ship Date_ สามารถสร้างตารางใหม่โดยการคัดลอกตาราง _Date_ ด้วยสูตร DAX ต่อไปนี้:

```DAX
Ship Date = 'Date'
````

สูตรนี้จะสร้างตารางชื่อ _Ship Date_ ที่มีคอลัมน์และแถวเหมือนกับ _Date_ เดิม และเมื่อ _Date_ ถูกรีเฟรช ตาราง _Ship Date_ จะอัปเดตตามโดยอัตโนมัติ จากนั้นสามารถสร้างความสัมพันธ์ที่เปิดใช้งานระหว่าง _Ship Date_ และ _Sales_ เพื่อให้กรองยอดขายตาม _Ship Date_ ได้

### **Configure duplicate tables**

เมื่อสร้าง _calculated table_ แล้ว คุณควรกำหนดค่าเพิ่มเติมให้กับตารางที่คัดลอก เช่น เปลี่ยนชื่อคอลัมน์เพื่อให้เข้าใจได้ชัดเจนขึ้น

ในตัวอย่างนี้ คอลัมน์ _Fiscal Year_ ในตาราง _Ship Date_ ควรถูกเปลี่ยนชื่อเป็น _Ship Fiscal Year_ และคอลัมน์ _Ship Full Date_ ควรเรียงลำดับตาม _Ship Date_ ส่วนคอลัมน์ _MonthKey_ สามารถซ่อนไว้เพื่อปรับปรุงการเรียงและการรายงาน

_calculated tables_ มีประโยชน์ในกรณีที่มีความสัมพันธ์หลายชุดระหว่างตาราง แต่ก็เพิ่มขนาดของโมเดลและอาจทำให้เวลาในการรีเฟรชนานขึ้น โดยเฉพาะหากตารางนั้นขึ้นกับตารางอื่น

> **Note**
> แม้ว่าการใช้ตารางซ้ำจะช่วยแก้ปัญหานี้ได้ แต่ยังมีแนวทางอื่นที่มีประสิทธิภาพมากกว่า ซึ่งจะพูดถึงในหัวข้อเกี่ยวกับ _measures_ ภายหลัง

## **Create a date table**

อีกหนึ่งกรณีการใช้งานที่ดีของ _calculated table_ คือการสร้าง _date table_ ซึ่งจำเป็นสำหรับการใช้ _time intelligence_

สามารถใช้ฟังก์ชัน CALENDARAUTO เพื่อสร้างตารางวันที่โดยอัตโนมัติ โดยฟังก์ชันนี้จะสแกนคอลัมน์ที่เป็นวันที่ทั้งหมดในโมเดล เพื่อหาระยะวันที่เริ่มต้นและสิ้นสุด แล้วสร้างชุดวันที่ให้ครอบคลุมปีงบประมาณทั้งหมด

เช่น การระบุค่า 6 จะหมายถึงสิ้นปีงบประมาณในเดือนมิถุนายน:

```
Due Date = CALENDARAUTO(6)
```

ตาราง _Due Date_ ที่ได้จะมีคอลัมน์เดียวชื่อ _Date_ แสดงชุดของวันที่เรียงจากเก่าไปใหม่

[![Screenshot shows the Due Date table in data view. There's one column named Date, and when the values are sorted earliest to latest, the first date is July 1, 2017.](https://learn.microsoft.com/en-us/training/modules/dax-power-bi-create-calculations/media/dax-due-date-table-data-view-1.png)](https://learn.microsoft.com/en-us/training/modules/dax-power-bi-create-calculations/media/dax-due-date-table-data-view-1.png#lightbox#lightbox)

> **Tip**
> ฟังก์ชัน CALENDAR ก็สามารถใช้สร้าง _date table_ ได้เช่นกัน โดยกำหนดวันที่เริ่มต้นและสิ้นสุดเป็นค่าคงที่หรือจากค่าที่ได้จากข้อมูลในโมเดล

หากวันที่เริ่มต้นในโมเดลคือ 15 ต.ค. 2021 และวันที่สุดท้ายคือ 15 มิ.ย. 2022 ฟังก์ชันจะคืนชุดวันที่ตั้งแต่ 1 ก.ค. 2021 ถึง 30 มิ.ย. 2022 เพื่อให้ครอบคลุมปีงบประมาณ ซึ่งจำเป็นต่อการกำหนดตารางให้เป็น _date table_

## **Mark as a date table**

เมื่อสร้าง _date table_ แล้ว ต้องใช้ฟังก์ชัน _Mark as a date table_ ใน _Power BI Desktop_ เพื่อให้สามารถใช้งาน _time intelligence_ ใน DAX ได้

เมื่อกำหนดตารางเป็น _date table_ Power BI จะตรวจสอบว่าคอลัมน์นั้น:

- มีค่าที่ไม่ซ้ำกัน
- ไม่มีค่า null
- มีลำดับวันที่ที่ต่อเนื่องจากต้นจนจบ
- ใช้ timestamp เดียวกันในแต่ละค่า (กรณีเป็นชนิด Date/Time)

การตั้งค่านี้ใช้ได้กับทุกตารางวันที่ ไม่ว่าจะนำเข้ามา หรือสร้างจาก _Power Query_ หรือจาก _calculated table_


> **Note**
> คุณต้องใช้ _custom date table_ หรือใช้ _auto/date time_ ที่มีใน Power BI เพื่อใช้งาน _time intelligence_ โดยที่ _auto/date time_ มีข้อจำกัดและไม่สามารถปรับแต่งได้ ซึ่งเป็นเหตุผลที่ควรใช้ตารางวันที่แบบกำหนดเอง

---

### Example Date Table 

| **Date**   | **Year** | **Month** | **MonthName** | **Quarter** | **Day** | **WeekdayName** |
| ---------- | -------- | --------- | ------------- | ----------- | ------- | --------------- |
| 2022-01-01 | 2022     | 1         | January       | Q1          | 1       | Saturday        |
| 2022-01-02 | 2022     | 1         | January       | Q1          | 2       | Sunday          |
| 2022-01-03 | 2022     | 1         | January       | Q1          | 3       | Monday          |
| …          | …        | …         | …             | …           | …       | …               |
| 2022-12-31 | 2022     | 12        | December      | Q4          | 31      | Saturday        |

```sql
DateTable = 
ADDCOLUMNS (
    CALENDAR (DATE(2022,1,1), DATE(2022,12,31)),
    "Year", YEAR([Date]),
    "Month", MONTH([Date]),
    "MonthName", FORMAT([Date], "MMMM"),
    "Quarter", "Q" & FORMAT([Date], "Q"),
    "Day", DAY([Date]),
    "WeekdayName", FORMAT([Date], "dddd")
)
```

