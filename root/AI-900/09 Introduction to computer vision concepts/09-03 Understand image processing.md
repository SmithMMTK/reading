
วิธีที่นิยมใช้ในการประมวลผลภาพ (_image processing_) คือการใช้ _filters_ เพื่อปรับเปลี่ยนค่าพิกเซลในภาพให้เกิดผลลัพธ์ทางภาพที่ต้องการ

_filter_ จะถูกนิยามโดย _array_ ของค่าพิกเซลที่เรียกว่า _filter kernel_  
ตัวอย่างเช่น คุณสามารถนิยาม _filter_ ที่มี _kernel_ ขนาด 3x3 ได้ตามตัวอย่างนี้:

```text
-1 -1 -1
-1  8 -1
-1 -1 -1
```

จากนั้น _kernel_ จะถูกนำไปทำการ _convolve_ ทั่วทั้งภาพ โดยการคำนวณ _weighted sum_ (ผลรวมแบบมีน้ำหนัก) สำหรับพิกเซลชุด 3x3 แต่ละชุด แล้วนำผลลัพธ์ที่ได้ไปใส่ไว้ในภาพใหม่

วิธีนี้จะช่วยให้ปรับค่าพิกเซลให้เกิดเอฟเฟกต์ที่ต้องการ เช่น ทำให้ภาพคมขึ้น เบลอ หรือเน้นขอบวัตถุ  
เพื่อให้เข้าใจการทำงานของ _filtering_ ได้ง่ายขึ้น ลองดูตัวอย่างแบบทีละขั้นตอน

เริ่มจากภาพ _grayscale_ ที่เราดูมาก่อนหน้านี้:

```text
 0   0   0   0   0   0   0  
 0   0   0   0   0   0   0
 0   0  255 255 255  0   0
 0   0  255 255 255  0   0
 0   0  255 255 255  0   0
 0   0   0   0   0   0   0
 0   0   0   0   0   0   0
```

ขั้นแรก เรานำ _filter kernel_ ไปใช้กับพิกเซลกลุ่มแรกที่มุมบนซ้ายของภาพ  
โดยการนำค่าพิกเซลแต่ละตัวในพื้นที่ 3x3 ไปคูณกับค่าน้ำหนัก (_weight_) ที่อยู่ในตำแหน่งเดียวกันของ _kernel_ แล้วนำผลลัพธ์ทั้งหมดมาบวกกัน

ผลรวมที่ได้จะถูกนำไปใส่ในตำแหน่งพิกเซลใหม่ของภาพผลลัพธ์ (_new image_) เพื่อสะท้อนเอฟเฟกต์ของ _filter_

```text
(0 x -1) + (0 x -1) + (0 x -1) +
(0 x -1) + (0 x 8) + (0 x -1) +
(0 x -1) + (0 x -1) + (255 x -1) = -255
```

ผลลัพธ์ที่ได้คือ -255 จะกลายเป็นค่าตัวแรกใน _array_ ใหม่  
จากนั้นเราจะเลื่อน _filter kernel_ ไปทางขวา 1 พิกเซล และทำขั้นตอนเดิมซ้ำอีกครั้ง:

คูณค่าพิกเซลในชุด 3x3 ใหม่กับค่าน้ำหนักใน _kernel_ แล้วบวกผลลัพธ์  
ค่าที่ได้จะถูกเพิ่มเข้าไปในตำแหน่งถัดไปของ _array_ ใหม่  
เราจะทำแบบนี้ไปเรื่อย ๆ จนกว่าจะครอบคลุมทั้งภาพ

```text
(0 x -1) + (0 x -1) + (0 x -1) +
(0 x -1) + (0 x 8) + (0 x -1) +
(0 x -1) + (255 x -1) + (255 x -1) = -510
```

จากนั้นนำผลลัพธ์ที่ได้จากการคำนวณครั้งที่สองมาเพิ่มใน _array_ ใหม่ ทำให้ตอนนี้ _array_ มีทั้งหมด 2 ค่าแล้ว:

```text
-255  -510
```

ขั้นตอนนี้จะถูกทำซ้ำไปเรื่อย ๆ จนกว่า _filter kernel_ จะถูก _convolve_ ทั่วทั้งภาพ  
ผลลัพธ์ที่ได้คือ _array_ ใหม่ที่ประกอบด้วยค่าพิกเซลที่ผ่านการปรับเปลี่ยนทั้งหมด ซึ่งแสดงให้เห็นภาพที่ถูกแปลงด้วย _filter_

ในภาพเคลื่อนไหวด้านล่างจะแสดงให้เห็นกระบวนการนี้อย่างชัดเจน:

![Diagram of a filter.](https://learn.microsoft.com/en-us/training/wwl-data-ai/introduction-computer-vision/media/filter.gif)

เมื่อ _filter_ ถูก _convolve_ ทั่วทั้งภาพ จะได้ _array_ ใหม่ของค่าพิกเซล  
บางค่าที่ได้อาจอยู่นอกช่วง 0 ถึง 255 ซึ่งเป็นช่วงค่าที่ถูกต้องสำหรับพิกเซล จึงต้องมีการปรับค่า (_clipping_) ให้กลับมาอยู่ในช่วงนี้

นอกจากนี้ เนื่องจากรูปทรงของ _kernel_ ทำให้ขอบของภาพไม่สามารถคำนวณได้ตรง ๆ จึงต้องใส่ _padding_ (มักใช้ค่า 0) รอบขอบภาพเพื่อให้การคำนวณเป็นไปได้

_array_ ที่ได้จะกลายเป็นภาพใหม่ที่ถูกแปลงโดย _filter_  
ในกรณีนี้ _filter_ ทำให้ภาพแสดงขอบของวัตถุได้ชัดเจนขึ้น (_highlighting edges_)

เพื่อให้เห็นผลลัพธ์ของ _filter_ ชัดเจนขึ้น นี่คือตัวอย่างของ _filter_ เดียวกันที่นำไปใช้กับภาพจริง:

|Original Image|Filtered Image|
|---|---|
|![Diagram of a banana.](https://learn.microsoft.com/en-us/training/wwl-data-ai/introduction-computer-vision/media/banana-grayscale.png)|![Diagram of a filtered banana.](https://learn.microsoft.com/en-us/training/wwl-data-ai/introduction-computer-vision/media/laplace.png)|

เนื่องจาก _filter_ ถูก _convolve_ ทั่วทั้งภาพ การปรับแต่งภาพแบบนี้จึงมักถูกเรียกว่า _convolutional filtering_

_filter_ ที่ใช้ในตัวอย่างนี้คือ _laplace filter_ ซึ่งเป็น _filter_ แบบหนึ่งที่เน้นขอบของวัตถุในภาพ (_edge detection_) ยังมี _filter_ อีกหลายประเภทที่สามารถใช้สร้างเอฟเฟกต์ต่าง ๆ ได้ เช่น การเบลอ (_blurring_), การทำให้ภาพคมขึ้น (_sharpening_), การกลับสี (_color inversion_) และอื่น ๆ

ถัดไป เราจะเชื่อมโยงแนวคิดของ _convolutional filtering_ เข้ากับโมเดล _vision_ สมัยใหม่