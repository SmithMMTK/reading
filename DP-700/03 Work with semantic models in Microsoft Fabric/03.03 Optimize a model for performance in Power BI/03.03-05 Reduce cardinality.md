
_Cardinality_ คือคำที่ใช้ในการอธิบายระดับความไม่ซ้ำกันของค่าภายในคอลัมน์หนึ่ง ๆ นอกจากนี้ _cardinality_ ยังถูกใช้ในบริบทของความสัมพันธ์ใน _model_ เพื่ออธิบายทิศทางของความสัมพันธ์ระหว่างตารางด้วย

## Identify cardinality levels in columns

ก่อนหน้านี้ เมื่อคุณใช้ Power Query เพื่อวิเคราะห์ _metadata_ ตัวเลือก **Column distribution** ในแถบ **View** จะแสดงสถิติเกี่ยวกับจำนวนรายการที่แตกต่าง (_distinct_) และไม่ซ้ำกัน (_unique_) ในแต่ละคอลัมน์ของข้อมูล

- **Distinct values count** – จำนวนค่าที่แตกต่างกันทั้งหมดที่พบในคอลัมน์นั้น
- **Unique values count** – จำนวนค่าที่ปรากฏเพียงครั้งเดียวในคอลัมน์นั้น

[![Screenshot shows column distribution statistics.](https://learn.microsoft.com/en-us/training/modules/optimize-model-power-bi/media/4-column-distribution-statistics-ssm.png)](https://learn.microsoft.com/en-us/training/modules/optimize-model-power-bi/media/4-column-distribution-statistics-ssm.png#lightbox#lightbox)

คอลัมน์ที่มีค่าซ้ำกันจำนวนมาก (ค่า _unique count_ ต่ำ) จะมี _cardinality_ ต่ำ ในทางกลับกัน คอลัมน์ที่มีค่าที่ไม่ซ้ำกันจำนวนมาก (ค่า _unique count_ สูง) จะมี _cardinality_ สูง

_cardinality_ ที่ต่ำจะช่วยให้ประสิทธิภาพดีขึ้น ดังนั้นคุณควรพยายามลดจำนวนคอลัมน์ที่มี _cardinality_ สูงใน _semantic model_ ของคุณ

_cardinality_ ที่ต่ำให้ประสิทธิภาพดีกว่าเพราะว่า _VertiPaq engine_ ซึ่งเป็นเอนจินที่ Power BI ใช้ในการบีบอัดและจัดเก็บข้อมูล ทำงานได้มีประสิทธิภาพสูงเมื่อข้อมูลมีค่าซ้ำกันมาก (หรือพูดอีกอย่างคือ _cardinality_ ต่ำ)

เหตุผลหลักคือ:

- **การบีบอัดข้อมูลได้ดีขึ้น** – ถ้าคอลัมน์มีค่าเหมือนกันซ้ำ ๆ เช่น "Male", "Female", "Male", "Male"... จะสามารถใช้เทคนิคการเข้ารหัสเช่น _dictionary encoding_ เพื่อแทนค่าด้วยตัวเลขที่ซ้ำกัน และลดขนาดของข้อมูลได้อย่างมาก
- **ใช้หน่วยความจำ (memory) น้อยลง** – เพราะข้อมูลถูกบีบอัดได้ดี ขนาดของโมเดลจึงเล็กลง ส่งผลให้ใช้หน่วยความจำและทรัพยากรน้อยลง
- **คิวรีและการคำนวณเร็วขึ้น** – เมื่อข้อมูลใช้ทรัพยากรน้อยลง การประมวลผล เช่นการกรอง การจัดกลุ่ม หรือการคำนวณ _DAX_ ก็ทำได้เร็วขึ้น

ในทางตรงข้าม หากคอลัมน์มี _cardinality_ สูง เช่น รหัสลูกค้า (CustomerID) ที่มีไม่ซ้ำกันเลยหลายหมื่นหรือหลายล้านค่า การบีบอัดจะทำได้น้อยลง ใช้หน่วยความจำมากขึ้น และทำให้ประสิทธิภาพโดยรวมของ _semantic model_ แย่ลง

**สรุป:** _Cardinality ต่ำ = บีบอัดง่าย = โมเดลเล็ก = ทำงานเร็ว_
## Reduce relationship cardinality

เมื่อคุณนำเข้าตารางหลายตาราง มีความเป็นไปได้ที่คุณจะต้องวิเคราะห์ข้อมูลจากทุกตารางร่วมกัน ความสัมพันธ์ (_relationships_) ระหว่างตารางเหล่านั้นจึงเป็นสิ่งจำเป็นเพื่อให้สามารถคำนวณผลลัพธ์ได้อย่างถูกต้องและแสดงข้อมูลในรายงานได้ตรงตามต้องการ Power BI Desktop ช่วยให้การสร้างความสัมพันธ์เหล่านี้ง่ายขึ้น และในหลายกรณีระบบจะสร้างให้อัตโนมัติผ่านฟีเจอร์ _autodetect_ โดยที่คุณไม่ต้องทำอะไร แต่บางครั้งคุณอาจจำเป็นต้องสร้างหรือแก้ไขความสัมพันธ์ด้วยตนเอง ดังนั้นการเข้าใจ _relationships_ และวิธีการสร้างหรือแก้ไขใน Power BI Desktop จึงเป็นสิ่งสำคัญ

เมื่อคุณสร้างหรือแก้ไขความสัมพันธ์ คุณสามารถกำหนดตัวเลือกอื่น ๆ ได้ โดยปกติ Power BI Desktop จะกำหนดค่าเริ่มต้นตามการประเมินข้อมูลในโมเดล ซึ่งอาจแตกต่างกันไปตามข้อมูลในแต่ละคอลัมน์

ความสัมพันธ์สามารถมีรูปแบบ _cardinality_ ที่แตกต่างกัน โดย _cardinality_ คือทิศทางของความสัมพันธ์ และแต่ละความสัมพันธ์ในโมเดลต้องระบุประเภท _cardinality_ ไว้ Power BI มีตัวเลือก _cardinality_ ดังนี้:

- **Many-to-one (M:1)** – เป็นความสัมพันธ์ที่พบบ่อยที่สุด หมายถึงคอลัมน์ในตารางหนึ่งสามารถมีค่าซ้ำกันได้หลายค่า ส่วนอีกตาราง (lookup table) จะมีค่าที่ไม่ซ้ำกัน
- **One-to-one (1:1)** – คอลัมน์ในทั้งสองตารางจะมีค่าที่ไม่ซ้ำกัน
- **One-to-many (1:M)** – คอลัมน์ในตารางหนึ่งมีค่าที่ไม่ซ้ำกัน ส่วนอีกตารางสามารถมีค่าซ้ำกันได้
- **Many-to-many (M:M)** – ใช้ได้ใน _composite models_ เพื่อสร้างความสัมพันธ์แบบหลายต่อหลาย โดยไม่จำเป็นต้องมีค่าที่ไม่ซ้ำกันในตาราง และไม่ต้องสร้างตารางเพิ่มเติมเพื่อเชื่อมความสัมพันธ์แบบเดิมอีกต่อไป

ระหว่างการพัฒนา คุณสามารถสร้างและแก้ไขความสัมพันธ์ในโมเดลได้ และไม่ว่าคุณจะใช้ _cardinality_ แบบใด ควรตรวจสอบให้แน่ใจว่าคอลัมน์ทั้งสองฝั่งที่ใช้สร้างความสัมพันธ์มีชนิดข้อมูล (_data type_) ตรงกัน โมเดลจะไม่สามารถทำงานได้หากคุณพยายามเชื่อมคอลัมน์ที่หนึ่งเป็นแบบ _text_ และอีกคอลัมน์เป็น _integer_

ในตัวอย่างต่อไปนี้ คอลัมน์ `ProductID` มีชนิดข้อมูลเป็น **Whole number** ทั้งในตาราง `Product` และ `Sales` ซึ่งชนิดข้อมูลแบบ **Integer** จะให้ประสิทธิภาพดีกว่าชนิด **Text**

[![Screenshot shows how to check data type of ProductID.](https://learn.microsoft.com/en-us/training/modules/optimize-model-power-bi/media/4-product-id-type-whole-number-ssm.png)](https://learn.microsoft.com/en-us/training/modules/optimize-model-power-bi/media/4-product-id-type-whole-number-ssm.png#lightbox#lightbox)

## Improve performance by reducing cardinality levels

Power BI Desktop มีเทคนิคหลากหลายที่ช่วยลดปริมาณข้อมูลที่โหลดเข้าไปใน _semantic model_ เช่น การสรุปข้อมูล (_summarization_) การลดปริมาณข้อมูลนี้จะช่วยปรับปรุง _relationship cardinality_ ของรายงานได้ ดังนั้นจึงควรพยายามลดข้อมูลที่โหลดเข้าโมเดลให้มากที่สุด โดยเฉพาะกับ _model_ ที่มีขนาดใหญ่หรือคาดว่าจะเติบโตจนมีขนาดใหญ่มากขึ้นในอนาคต

หนึ่งในเทคนิคที่ได้ผลดีที่สุดในการลดขนาด _model_ คือการใช้ _summary table_ จาก _data source_ แทนที่จะโหลด _detail table_ ที่มีทุก _transaction_ เช่น ตารางสรุปอาจมีเพียงหนึ่งแถวต่อวัน ต่อสัปดาห์ หรือ ต่อเดือน โดยรวมยอดรวมของ _transaction amount_ ต่อวัน เป็นต้น

ตัวอย่างเช่น ตาราง _sales fact_ ต้นทางอาจบันทึกหนึ่งแถวต่อหนึ่งรายการสั่งซื้อ หากคุณสรุปข้อมูลยอดขายโดยจัดกลุ่มตามวันที่ ลูกค้า และสินค้า ก็จะสามารถลดข้อมูลได้มาก หากไม่จำเป็นต้องใช้ _transaction_ รายละเอียด

นอกจากนี้ การสรุปข้อมูลในระดับเดือนจะช่วยลดขนาดของ _model_ ได้อย่างมีนัยสำคัญ เช่น อาจลดลงได้ถึง 99% แต่จะไม่สามารถรายงานในระดับวันหรือระดับคำสั่งซื้อได้อีกต่อไป การตัดสินใจสรุปข้อมูลใน _fact table_ เป็นเรื่องที่ต้องแลกกับความละเอียดของข้อมูล ข้อเสียคือคุณอาจไม่สามารถเจาะลึกข้อมูล (_drill into data_) ได้อีกต่อไปเพราะข้อมูลรายละเอียดหายไปแล้ว อย่างไรก็ตาม ข้อเสียนี้สามารถบรรเทาได้โดยการใช้ _Composite model_

ใน Power BI Desktop คุณสามารถกำหนด _storage mode_ แยกตามแต่ละตารางได้ใน _Composite model_ โดยกำหนดค่า **Storage Mode** เป็น **Import** หรือ **DirectQuery** ให้กับแต่ละตารางได้

อีกเทคนิคหนึ่งที่ช่วยลดขนาด _model_ ได้ดีคือการตั้งค่า **Storage Mode** สำหรับ _fact table_ ขนาดใหญ่ให้เป็น **DirectQuery** วิธีออกแบบนี้สามารถใช้งานร่วมกับเทคนิคการสรุปข้อมูลได้อย่างมีประสิทธิภาพ เช่น คุณสามารถใช้ข้อมูลยอดขายแบบสรุปเพื่อให้รายงานหลักทำงานได้อย่างรวดเร็ว แล้วสร้างหน้า _drillthrough_ สำหรับดูรายละเอียดของยอดขายภายใต้บริบทที่แคบ เช่น คำสั่งซื้อทั้งหมดในช่วงเวลาหนึ่ง โดยใช้ _visuals_ ที่อ้างอิงข้อมูลจากตารางแบบ _DirectQuery_ เพื่อดึงข้อมูลคำสั่งซื้อในเชิงลึกมาแสดง

For more information, see [Data reduction techniques for Import modeling](https://learn.microsoft.com/en-us/power-bi/guidance/import-modeling-data-reduction/#group-by-and-summarize).

---

## Next unit: Optimize DirectQuery models with table level storage