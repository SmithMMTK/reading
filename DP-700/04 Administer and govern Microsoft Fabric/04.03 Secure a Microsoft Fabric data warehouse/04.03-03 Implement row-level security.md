
[Row-Level Security (RLS)](https://learn.microsoft.com/en-us/fabric/data-warehouse/row-level-security) คือฟีเจอร์ที่ช่วยให้สามารถควบคุมการเข้าถึงข้อมูลในระดับ *row* ของ *table* ได้อย่างละเอียด โดยพิจารณาจาก *group membership* หรือ *execution context*

ตัวอย่างเช่น ในระบบ *e-commerce* คุณสามารถกำหนดให้ผู้ขายเห็นเฉพาะแถวของคำสั่งซื้อที่เกี่ยวข้องกับสินค้าของตนเองเท่านั้น ด้วยวิธีนี้ ผู้ขายแต่ละรายจะสามารถจัดการคำสั่งซื้อของตนเองได้อย่างเป็นอิสระ ในขณะที่ยังคงรักษาความเป็นส่วนตัวของคำสั่งซื้อของผู้ขายรายอื่น

หากคุณเคยมีประสบการณ์กับ *SQL Server* จะพบว่า *Row-Level Security* นี้มีลักษณะและฟีเจอร์ที่คล้ายกัน

## Protect your data

_Row-Level Security (RLS)_ ทำงานโดยการเชื่อมโยง *function* ที่เรียกว่า *security predicate* เข้ากับ *table* โดย *function* นี้จะคืนค่า _true_ หรือ _false_ ตามเงื่อนไขที่กำหนด ซึ่งมักจะพิจารณาจากค่าของหนึ่งหรือหลายคอลัมน์ภายใน *table* นั้น

เมื่อผู้ใช้พยายามเข้าถึงข้อมูลใน *table* ระบบจะเรียกใช้ *security predicate function* นี้ หาก *function* คืนค่า _true_ แถวข้อมูลนั้นจะสามารถเข้าถึงได้ แต่ถ้าคืนค่า _false_ แถวนั้นจะไม่แสดงในผลลัพธ์ของ *query*

ขึ้นอยู่กับความต้องการทางธุรกิจ *RLS predicate* อาจเรียบง่ายอย่างเช่น `WHERE CustomerId = 29` หรือซับซ้อนเท่าที่จำเป็นก็ได้

กระบวนการนี้ทำงานแบบ *transparent* สำหรับผู้ใช้ และถูกบังคับใช้โดยอัตโนมัติโดย *SQL Server* เพื่อให้มั่นใจว่ากฎการรักษาความปลอดภัยถูกใช้สม่ำเสมอ

การใช้งาน *Row-Level Security* มี 2 ขั้นตอนหลัก:

- **Filter predicates** – เป็น *inline table-valued function* ที่ทำหน้าที่กรองผลลัพธ์ตามเงื่อนไขของ *predicate* ที่กำหนดไว้

| Access     | Definition                           |
| ---------- | ------------------------------------ |
| **SELECT** | Can't view rows that are filtered.   |
| **UPDATE** | Can't update rows that are filtered. |
| **DELETE** | Can't delete rows that are filtered. |
| **INSERT** | Not applicable.                      |

- **Security policy** – เป็น *security policy* ที่เรียกใช้ *inline table-valued function* เพื่อป้องกันการเข้าถึงแถวข้อมูลใน *table*

เนื่องจากการควบคุมการเข้าถึงถูกกำหนดและบังคับใช้ในระดับ *warehouse* จึงแทบไม่จำเป็นต้องแก้ไขโค้ดของแอปพลิเคชันเลย หรืออาจไม่ต้องแก้ไขเลยด้วยซ้ำ อีกทั้งผู้ใช้ยังสามารถเข้าถึง *tables* ได้โดยตรง และสามารถ *query* ข้อมูลของตนเองได้

## Configure row-level security

The T-SQL commands below demonstrate how to use RLS in a scenario where user access is segregated by tenant:

```sql
-- Create supporting objects for this example
CREATE TABLE [Sales] (SalesID INT, 
    ProductID INT, 
    TenantName NVARCHAR(50), 
    OrderQty INT, 
    UnitPrice MONEY)
GO

INSERT INTO [Sales]  VALUES (1, 3, 'tenant1@contoso.com', 5, 10.00);
INSERT INTO [Sales]  VALUES (2, 4, 'tenant2@contoso.com', 2, 57.00);
INSERT INTO [Sales]  VALUES (3, 7, 'tenant3@contoso.com', 4, 23.00);
INSERT INTO [Sales]  VALUES (4, 2, 'tenant4@contoso.com', 2, 91.00);
INSERT INTO [Sales]  VALUES (5, 9, 'tenant5@contoso.com', 5, 80.00);

-- View all the rows in the table  
SELECT * FROM Sales;
```

ถัดไป เราจะสร้าง *schema* ใหม่, *inline table-valued function*, และกำหนดสิทธิ์ให้ผู้ใช้สามารถเข้าถึง *function* ใหม่นี้ได้ โดยเงื่อนไข `WHERE @TenantName = USER_NAME() OR USER_NAME() = 'TenantAdmin'` จะตรวจสอบว่า *user name* ที่รัน *query* ตรงกับค่าคอลัมน์ _TenantName_ หรือไม่

หากตรงกัน หรือหากผู้ใช้นั้นคือ 'TenantAdmin' ก็จะสามารถเข้าถึงแถวนั้นได้

```sql
--Create a schema
CREATE SCHEMA [Sec];  
GO  

--Create the filter predicate
CREATE FUNCTION sec.tvf_SecurityPredicatebyTenant(@TenantName AS NVARCHAR(10))  
    RETURNS TABLE  
WITH SCHEMABINDING  
AS  
    RETURN	SELECT 1 AS result
			WHERE @TenantName = USER_NAME() OR USER_NAME() = 'tenantAdmin@contoso.com';  
GO

--Create security policy and add the filter predicate
CREATE SECURITY POLICY sec.SalesPolicy  
ADD FILTER PREDICATE sec.tvf_SecurityPredicatebyTenant(TenantName) ON [dbo].[Sales]
WITH (STATE = ON);  
GO
```

ผู้ใช้ _tenantAdmin@contoso.com_ ควรจะเห็นทุกแถวของข้อมูล ส่วนผู้ใช้ _tenant1@contoso.com_ ถึง _tenant5@contoso.com_ ควรจะเห็นเฉพาะแถวของตัวเองเท่านั้น

ถ้าคุณแก้ไข _security policy_ โดยใช้ `WITH (STATE = OFF);` คุณจะสังเกตได้ว่าผู้ใช้ทุกคนสามารถเห็นข้อมูลทุกแถวได้

> **หมายเหตุ**  
> มีความเสี่ยงในการรั่วไหลของข้อมูล (_information leakage_) หากผู้ไม่หวังดีเขียน _query_ ที่มีเงื่อนไข _WHERE_ แบบพิเศษ เช่น ใช้การหารด้วยศูนย์ (_divide-by-zero error_) เพื่อบังคับให้เกิดข้อผิดพลาดเมื่อเงื่อนไข _WHERE_ เป็นจริง ซึ่งวิธีนี้เรียกว่า _side-channel attack_

## Explore use cases

_row-level security (RLS)_ เหมาะสำหรับหลายสถานการณ์ เช่น:

- เมื่อต้องการแยกการเข้าถึงข้อมูลในระดับแถวตามแต่ละแผนก
- เมื่อต้องการจำกัดให้ลูกค้าเห็นเฉพาะข้อมูลที่เกี่ยวข้องกับบริษัทของตนเองเท่านั้น
- เมื่อต้องการจำกัดการเข้าถึงข้อมูลตามข้อกำหนดด้านกฎระเบียบ (_compliance_)

## Apply best practices

แนวทางปฏิบัติที่ควรพิจารณาเมื่อนำ _RLS_ ไปใช้:

- แนะนำให้สร้าง _schema_ แยกต่างหากสำหรับ _predicate functions_ และ _security policies_
- หากเป็นไปได้ ควรหลีกเลี่ยงการแปลงชนิดข้อมูล (_type conversions_) ใน _predicate functions_
- เพื่อให้ประสิทธิภาพสูงสุด ควรหลีกเลี่ยงการใช้ _table joins_ มากเกินไป และไม่ควรมีการเรียกซ้ำ (_recursion_) ภายใน _predicate functions_

---

## Next unit: Implement column-level security