
ความสามารถในการจัดเก็บ _ข้อมูล_ ในรูปแบบไฟล์เป็นองค์ประกอบพื้นฐานของระบบคอมพิวเตอร์ทุกระบบ ไฟล์สามารถจัดเก็บใน _local file system_ บนฮาร์ดดิสก์ของคอมพิวเตอร์ส่วนบุคคล หรือบนสื่อบันทึกแบบถอดได้ เช่น USB drive แต่ในหลายองค์กร _ไฟล์ข้อมูล_ ที่สำคัญจะถูกจัดเก็บแบบรวมศูนย์ในระบบ _shared file storage_

แนวโน้มปัจจุบันคือการย้าย _file storage_ ไปยังระบบ _cloud_ มากขึ้น เพื่อให้สามารถจัดเก็บ _ข้อมูล_ ปริมาณมากได้อย่างคุ้มค่า มีความปลอดภัย และเชื่อถือได้

รูปแบบของ _file format_ ที่ใช้ในการจัดเก็บ _ข้อมูล_ จะขึ้นอยู่กับหลายปัจจัย เช่น

- ประเภทของ _ข้อมูล_ ที่จัดเก็บ (_structured_, _semi-structured_, หรือ _unstructured_)
- แอปพลิเคชันหรือบริการที่ต้องใช้ในการอ่าน เขียน หรือประมวลผล _ข้อมูล_
- ความต้องการให้ _ข้อมูล_ อ่านได้ง่ายสำหรับมนุษย์ หรือเน้นการจัดเก็บและประมวลผลที่มีประสิทธิภาพ

เราจะพูดถึง _file format_ ที่ใช้กันทั่วไปในหัวข้อด้านล่าง

## Delimited text files

ข้อมูลมักถูกจัดเก็บในรูปแบบ _plain text_ โดยใช้ตัวคั่นฟิลด์ (_field delimiters_) และตัวแบ่งบรรทัด (_row terminators_) รูปแบบที่ใช้กันแพร่หลายที่สุดคือ _CSV (comma-separated values)_ ซึ่งฟิลด์ต่าง ๆ จะถูกคั่นด้วยเครื่องหมายคอมมา (,) และแต่ละแถวจะสิ้นสุดด้วยการขึ้นบรรทัดใหม่ โดยอาจมีบรรทัดแรกที่ระบุชื่อฟิลด์ไว้ด้วยก็ได้

รูปแบบอื่นที่พบบ่อยได้แก่ _TSV (tab-separated values)_, การใช้ช่องว่าง (_space-delimited_) หรือการใช้รูปแบบ _fixed-width_ ซึ่งแต่ละฟิลด์จะถูกกำหนดความยาวตัวอักษรแบบคงที่

ไฟล์ _delimited text_ เป็นตัวเลือกที่ดีสำหรับ _structured data_ ที่ต้องการให้แอปพลิเคชันหรือบริการหลากหลายเข้าถึงได้ และยังสามารถอ่านได้ง่ายโดยมนุษย์
#dp-900-key 

ตัวอย่างด้านล่างแสดงข้อมูลลูกค้าในรูปแบบ _comma-delimited_

```csv
FirstName,LastName,Email
Joe,Jones,joe@litware.com
Samir,Nadoy,samir@northwind.com
```

## JavaScript Object Notation (JSON)

_JSON_ เป็นรูปแบบที่ใช้กันอย่างแพร่หลาย โดยใช้โครงสร้างแบบลำดับชั้น (_hierarchical document schema_) เพื่อกำหนด _data entities_ (เรียกว่า _objects_) ซึ่งมี _attributes_ หลายรายการ _attribute_ แต่ละตัวอาจเป็น _object_ อีกตัวหนึ่ง หรือเป็นชุดของ _objects_ ก็ได้ ทำให้ _JSON_ เป็นรูปแบบที่มีความยืดหยุ่น เหมาะสำหรับทั้ง _structured_ และ _semi-structured data_
#dp-900-key 

ตัวอย่างด้านล่างแสดงเอกสาร _JSON_ ที่มีข้อมูลลูกค้าหลายคน โดยแต่ละลูกค้ามี 3 _attributes_ ได้แก่ _firstName_, _lastName_ และ _contact_ ซึ่ง _contact_ จะเป็นชุดของ _objects_ ที่แสดงช่องทางการติดต่อ เช่น อีเมลหรือเบอร์โทรศัพท์

โปรดสังเกตว่า _objects_ จะอยู่ภายในวงเล็บปีกกา (**{..}**) และ _collections_ จะอยู่ในวงเล็บเหลี่ยม (**[..]**) แต่ละ _attribute_ แสดงด้วยคู่ _name: value_ และคั่นแต่ละรายการด้วยเครื่องหมายคอมมา (**","**)


```json
{
  "customers":
  [
    {
      "firstName": "Joe",
      "lastName": "Jones",
      "contact":
      [
        {
          "type": "home",
          "number": "555 123-1234"
        },
        {
          "type": "email",
          "address": "joe@litware.com"
        }
      ]
    },
    {
      "firstName": "Samir",
      "lastName": "Nadoy",
      "contact":
      [
        {
          "type": "email",
          "address": "samir@northwind.com"
        }
      ]
    }
  ]
}
```

## Extensible Markup Language (XML)

_XML_ เป็นรูปแบบข้อมูลที่มนุษย์สามารถอ่านได้ (_human-readable_) ซึ่งได้รับความนิยมในช่วงปี 1990–2000 แม้ว่าปัจจุบันจะถูกแทนที่ด้วย _JSON_ ซึ่งกระชับและเรียบง่ายกว่า แต่ก็ยังมีบางระบบที่ใช้ _XML_ ในการแสดง _ข้อมูล_

_XML_ ใช้ _tags_ ที่อยู่ในวงเล็บแหลม (**<.../>**) เพื่อกำหนด _elements_ และ _attributes_ ดังตัวอย่างด้านล่าง


```xml
<Customers>
  <Customer name="Joe" lastName="Jones">
    <ContactDetails>
      <Contact type="home" number="555 123-1234"/>
      <Contact type="email" address="joe@litware.com"/>
    </ContactDetails>
  </Customer>
  <Customer name="Samir" lastName="Nadoy">
    <ContactDetails>
      <Contact type="email" address="samir@northwind.com"/>
    </ContactDetails>
  </Customer>
</Customers>
```

## Binary Large Object (BLOB)

ท้ายที่สุดแล้ว ไฟล์ทุกไฟล์จะถูกจัดเก็บในรูปแบบ _binary data_ (ชุดของ 1 และ 0) แต่สำหรับรูปแบบที่มนุษย์อ่านได้ซึ่งกล่าวถึงก่อนหน้านี้ ไบต์ของ _binary data_ จะถูกแปลงให้ตรงกับอักขระที่พิมพ์ได้ (โดยใช้ _character encoding_ เช่น ASCII หรือ Unicode)

อย่างไรก็ตาม สำหรับบาง _file format_ โดยเฉพาะที่ใช้กับ _unstructured data_ ข้อมูลจะถูกเก็บในรูปแบบ _raw binary_ ซึ่งต้องให้แอปพลิเคชันมาช่วยตีความและแสดงผล ตัวอย่างที่พบบ่อยของ _ข้อมูล_ ที่เก็บเป็นไบนารีได้แก่ รูปภาพ วิดีโอ ไฟล์เสียง และเอกสารเฉพาะทางของแอปพลิเคชัน

เมื่อต้องทำงานกับ _ข้อมูล_ ประเภทนี้ ผู้เชี่ยวชาญด้านข้อมูลมักจะเรียกไฟล์เหล่านี้ว่า _BLOBs_ (_Binary Large Objects_)

## Optimized file formats

แม้ว่า _human-readable format_ สำหรับ _structured_ และ _semi-structured data_ จะมีประโยชน์ในหลายกรณี แต่มักไม่เหมาะสำหรับการจัดเก็บหรือประมวลผลที่ต้องการประสิทธิภาพสูง ดังนั้นจึงมีการพัฒนา _file format_ เฉพาะทางที่รองรับ _compression_, _indexing_ และการประมวลผลอย่างมีประสิทธิภาพ

ตัวอย่าง _optimized file format_ ที่พบได้บ่อย ได้แก่ _Avro_, _ORC_ และ _Parquet_:

- _Avro_ เป็นรูปแบบแบบ _row-based_ พัฒนาโดย Apache ในแต่ละเรกคอร์ดจะมี _header_ ที่อธิบายโครงสร้างของข้อมูล ซึ่ง _header_ จะถูกจัดเก็บในรูปแบบ _JSON_ ส่วนข้อมูลจริงจะอยู่ในรูปแบบ _binary_ แอปพลิเคชันจะใช้ข้อมูลใน _header_ เพื่ออ่านและแปลง _binary data_ ให้ได้ฟิลด์ที่ต้องการ _Avro_ เหมาะสำหรับการบีบอัดข้อมูลและลดพื้นที่จัดเก็บและปริมาณแบนด์วิดท์เครือข่าย

- _ORC_ (_Optimized Row Columnar format_) เป็นรูปแบบ _column-based_ พัฒนาโดย HortonWorks เพื่อให้เหมาะกับการใช้งานใน Apache Hive (ระบบ data warehouse ที่รองรับการสรุปผลและค้นหาข้อมูลจาก dataset ขนาดใหญ่) ไฟล์ ORC จะถูกแบ่งออกเป็น _stripes_ ซึ่งเก็บข้อมูลของแต่ละคอลัมน์หรือกลุ่มคอลัมน์ แต่ละ _stripe_ มี _index_, ข้อมูลของแถวต่าง ๆ และ _footer_ ที่มีสถิติเช่น count, sum, max, min สำหรับแต่ละคอลัมน์

- _Parquet_ เป็นอีกหนึ่งรูปแบบ _columnar format_ พัฒนาโดย Cloudera และ X ไฟล์ Parquet จะถูกแบ่งออกเป็น _row groups_ ซึ่งภายในแต่ละกลุ่มจะแบ่งเป็นหลาย _chunks_ ข้อมูลของแต่ละคอลัมน์จะถูกเก็บรวมกันในกลุ่มเดียวกัน ไฟล์ Parquet ยังมี _metadata_ ที่บรรยายแถวในแต่ละ chunk ทำให้แอปพลิเคชันสามารถค้นหา _chunk_ ที่ต้องการได้อย่างรวดเร็วและดึงเฉพาะคอลัมน์ที่ต้องการมาใช้งาน _Parquet_ มีจุดเด่นเรื่องการจัดเก็บข้อมูลซ้อนแบบ _nested data types_ และรองรับการบีบอัดและเข้ารหัสข้อมูลได้อย่างมีประสิทธิภาพ